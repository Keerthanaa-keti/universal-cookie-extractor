<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Cookie Extractor - Test Harness</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f2f5;
            display: flex;
            gap: 24px;
        }

        /* Test controls panel */
        .test-panel {
            width: 360px;
            flex-shrink: 0;
            background: #1a1a2e;
            color: #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        .test-panel h2 {
            margin: 0 0 16px;
            color: #00d4ff;
            font-size: 16px;
        }
        .test-panel label {
            display: block;
            margin: 12px 0 4px;
            font-size: 13px;
            color: #aaa;
        }
        .test-panel select, .test-panel button {
            width: 100%;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #333;
            background: #16213e;
            color: #e0e0e0;
            font-size: 13px;
            cursor: pointer;
        }
        .test-panel button {
            background: #00d4ff;
            color: #1a1a2e;
            border: none;
            font-weight: 600;
            margin-top: 12px;
        }
        .test-panel button:hover {
            background: #00b8d4;
        }
        .test-panel button.secondary {
            background: #4a4a6a;
            color: #e0e0e0;
        }
        .test-panel button.secondary:hover {
            background: #5a5a7a;
        }
        .test-log {
            margin-top: 16px;
            background: #0f0f1a;
            border-radius: 6px;
            padding: 12px;
            font-family: 'SF Mono', monospace;
            font-size: 11px;
            max-height: 500px;
            overflow-y: auto;
            line-height: 1.6;
        }
        .test-log .pass { color: #4caf50; }
        .test-log .fail { color: #f44336; }
        .test-log .info { color: #00d4ff; }
        .test-log .section { color: #ff9800; font-weight: bold; margin-top: 8px; }

        /* Extension popup frame */
        .popup-frame {
            width: 460px;
            flex-shrink: 0;
        }
        .popup-frame h3 {
            margin: 0 0 8px;
            color: #333;
            font-size: 14px;
        }
        .popup-frame .subtitle {
            font-size: 12px;
            color: #666;
            margin-bottom: 12px;
        }
        .popup-container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .popup-container iframe {
            border: none;
            width: 100%;
            height: 700px;
        }
    </style>
</head>
<body>
    <!-- Test Controls -->
    <div class="test-panel">
        <h2>Test Harness v2.0</h2>
        <p style="font-size: 12px; color: #888; margin: 0 0 16px;">
            Tests popup UI, background auto-collection, content script DOM injection, and Claude in Chrome access patterns.
        </p>

        <label>Mock Website</label>
        <select id="mockSite">
            <option value="www.linkedin.com">LinkedIn (12 cookies)</option>
            <option value="www.facebook.com">Facebook (6 cookies)</option>
            <option value="www.google.com">Google (7 cookies)</option>
            <option value="example.com">Example.com (3 cookies)</option>
        </select>

        <button id="btnApplySite">Apply & Reload</button>

        <label style="margin-top: 20px;">Automated Tests</label>
        <button id="btnRunTests">Run All Tests</button>
        <button id="btnRunPopupTests" class="secondary">Popup Tests Only</button>
        <button id="btnRunAutoTests" class="secondary">Auto-Collection Tests Only</button>

        <div class="test-log" id="testLog">
            <div class="info">Ready. Select a site and click "Apply & Reload" to begin.</div>
        </div>
    </div>

    <!-- Extension Popup in iframe -->
    <div class="popup-frame">
        <h3>Extension Popup Preview</h3>
        <div class="subtitle">Simulating: <strong id="currentMockSite">www.linkedin.com</strong></div>
        <div class="popup-container">
            <iframe id="popupFrame" src="test-popup.html"></iframe>
        </div>
    </div>

    <script>
        function getPopupDoc() {
            return document.getElementById('popupFrame').contentDocument;
        }

        function getPopupWin() {
            return document.getElementById('popupFrame').contentWindow;
        }

        function applySite() {
            const site = document.getElementById('mockSite').value;
            document.getElementById('currentMockSite').textContent = site;
            log('info', `Switching to ${site}...`);
            const frame = document.getElementById('popupFrame');
            frame.src = `test-popup.html?site=${encodeURIComponent(site)}`;
            frame.onload = function() {
                log('pass', `Loaded ${site} mock`);
            };
        }

        function log(type, message) {
            const logEl = document.getElementById('testLog');
            const line = document.createElement('div');
            line.className = type;
            const prefix = type === 'pass' ? 'PASS' : type === 'fail' ? 'FAIL' : type === 'section' ? '====': 'INFO';
            line.textContent = `[${prefix}] ${message}`;
            logEl.appendChild(line);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function clearLog() {
            document.getElementById('testLog').innerHTML = '';
        }

        // ==========================================
        // POPUP TESTS (original tests)
        // ==========================================
        async function runPopupTests() {
            log('section', 'POPUP UI TESTS');

            const doc = getPopupDoc();
            const win = getPopupWin();
            let passed = 0;
            let failed = 0;

            // Test 1: Mock Chrome APIs exist in iframe
            try {
                if (win.chrome && win.chrome.cookies && win.chrome.tabs) {
                    log('pass', 'Chrome APIs are mocked');
                    passed++;
                } else {
                    throw new Error('Chrome APIs not found');
                }
            } catch(e) { log('fail', `Chrome APIs: ${e.message}`); failed++; }

            // Test 2: cookies.getAll returns data
            try {
                const all = await win.chrome.cookies.getAll({});
                if (all.length > 0) {
                    log('pass', `getAll({}) returned ${all.length} cookies`);
                    passed++;
                } else {
                    throw new Error('No cookies returned');
                }
            } catch(e) { log('fail', `getAll: ${e.message}`); failed++; }

            // Test 3: Domain filtering works
            try {
                const linkedin = await win.chrome.cookies.getAll({ domain: 'www.linkedin.com' });
                if (linkedin.length > 0) {
                    log('pass', `Domain filter: ${linkedin.length} LinkedIn cookies`);
                    passed++;
                } else {
                    throw new Error('No LinkedIn cookies returned');
                }
            } catch(e) { log('fail', `Domain filter: ${e.message}`); failed++; }

            // Test 4: Parent domain filtering (.linkedin.com)
            try {
                const parent = await win.chrome.cookies.getAll({ domain: '.linkedin.com' });
                if (parent.length > 0) {
                    log('pass', `Parent domain filter: ${parent.length} cookies for .linkedin.com`);
                    passed++;
                } else {
                    throw new Error('No parent domain cookies');
                }
            } catch(e) { log('fail', `Parent domain: ${e.message}`); failed++; }

            // Test 5: Auth cookie detection
            try {
                const allCookies = await win.chrome.cookies.getAll({});
                const authPatterns = ['auth', 'session', 'token', 'login', 'user', 'csrf', 'xsrf',
                    'li_at', 'c_user', 'xs', 'fr', 'sb', 'datr', 'auth_token', 'twid', 'ct0',
                    'sessionid', 'csrftoken', 'SID', 'HSID', 'SSID', 'APISID', 'SAPISID',
                    'JSESSIONID', 'PHPSESSID', 'ASP.NET_SessionId'];
                const authCookies = allCookies.filter(c =>
                    authPatterns.some(p => c.name.toLowerCase().includes(p.toLowerCase()))
                );
                if (authCookies.length > 0) {
                    log('pass', `Auth detection: ${authCookies.length} auth cookies identified`);
                    passed++;
                } else {
                    throw new Error('No auth cookies detected');
                }
            } catch(e) { log('fail', `Auth detection: ${e.message}`); failed++; }

            // Test 6: Session vs persistent distinction
            try {
                const allCookies = await win.chrome.cookies.getAll({});
                const sessions = allCookies.filter(c => !c.expirationDate);
                const persistent = allCookies.filter(c => c.expirationDate);
                if (sessions.length > 0 && persistent.length > 0) {
                    log('pass', `Session/persistent: ${sessions.length} session, ${persistent.length} persistent`);
                    passed++;
                } else {
                    throw new Error(`Session: ${sessions.length}, Persistent: ${persistent.length}`);
                }
            } catch(e) { log('fail', `Session/persistent: ${e.message}`); failed++; }

            // Test 7: Cookie flags present
            try {
                const allCookies = await win.chrome.cookies.getAll({});
                const hasSecure = allCookies.some(c => c.secure === true);
                const hasHttpOnly = allCookies.some(c => c.httpOnly === true);
                const hasSameSite = allCookies.some(c => c.sameSite);
                if (hasSecure && hasHttpOnly && hasSameSite) {
                    log('pass', 'Cookie flags: secure, httpOnly, sameSite all present');
                    passed++;
                } else {
                    throw new Error('Missing cookie flags');
                }
            } catch(e) { log('fail', `Cookie flags: ${e.message}`); failed++; }

            // Test 8: UI elements exist in popup
            try {
                const loadBtn = doc.getElementById('loadCookiesBtn');
                const extractAllBtn = doc.getElementById('extractAllBtn');
                const output = doc.getElementById('output');
                if (loadBtn && extractAllBtn && output) {
                    log('pass', 'UI elements: Load, Extract All, Output all present');
                    passed++;
                } else {
                    throw new Error('Missing UI elements');
                }
            } catch(e) { log('fail', `UI elements: ${e.message}`); failed++; }

            // Test 9: Load cookies button works
            try {
                doc.getElementById('loadCookiesBtn').click();
                await new Promise(r => setTimeout(r, 500));
                const cookieList = doc.getElementById('cookieList');
                if (cookieList && cookieList.children.length > 0) {
                    log('pass', `Load cookies: ${cookieList.children.length} cookies rendered`);
                    passed++;
                } else {
                    throw new Error('Cookie list empty after clicking Load');
                }
            } catch(e) { log('fail', `Load cookies: ${e.message}`); failed++; }

            // Test 10: Select All / None toggles work
            try {
                doc.getElementById('selectAllBtn').click();
                await new Promise(r => setTimeout(r, 100));
                const allChecked = doc.querySelectorAll('.cookie-checkbox:checked').length;

                doc.getElementById('selectNoneBtn').click();
                await new Promise(r => setTimeout(r, 100));
                const noneChecked = doc.querySelectorAll('.cookie-checkbox:checked').length;

                if (allChecked > 0 && noneChecked === 0) {
                    log('pass', `Select All/None: All=${allChecked}, None=${noneChecked}`);
                    passed++;
                } else {
                    throw new Error(`All=${allChecked}, None=${noneChecked}`);
                }
            } catch(e) { log('fail', `Select All/None: ${e.message}`); failed++; }

            // Test 11: Extract selected produces valid JSON
            try {
                doc.getElementById('selectAllBtn').click();
                await new Promise(r => setTimeout(r, 100));
                doc.getElementById('extractSelectedBtn').click();
                await new Promise(r => setTimeout(r, 200));
                const output = doc.getElementById('output');
                const data = JSON.parse(output.value);
                if (data.cookies && data.cookies.length > 0 && data.extractionType === 'selected_cookies') {
                    log('pass', `Extract selected: ${data.cookies.length} cookies, valid JSON`);
                    passed++;
                } else {
                    throw new Error('Invalid extraction output');
                }
            } catch(e) { log('fail', `Extract selected: ${e.message}`); failed++; }

            // Test 12: Extract All Sites works
            try {
                doc.getElementById('extractAllBtn').click();
                await new Promise(r => setTimeout(r, 500));
                const output = doc.getElementById('output');
                const data = JSON.parse(output.value);
                if (data.extractionType === 'all_sites' && data.totalCookies > 0 && data.domainCount > 1) {
                    log('pass', `Extract all: ${data.totalCookies} cookies from ${data.domainCount} domains`);
                    passed++;
                } else {
                    throw new Error('Invalid all-sites extraction');
                }
            } catch(e) { log('fail', `Extract all: ${e.message}`); failed++; }

            return { passed, failed };
        }

        // ==========================================
        // AUTO-COLLECTION & CONTENT SCRIPT TESTS
        // ==========================================
        async function runAutoCollectionTests() {
            log('section', 'AUTO-COLLECTION & CONTENT SCRIPT TESTS');

            const win = getPopupWin();
            let passed = 0;
            let failed = 0;

            // Test 13: chrome.storage.local mock works
            try {
                await win.chrome.storage.local.set({ testKey: 'testValue' });
                const result = await new Promise(resolve => {
                    win.chrome.storage.local.get('testKey', resolve);
                });
                if (result.testKey === 'testValue') {
                    log('pass', 'chrome.storage.local set/get works');
                    passed++;
                } else {
                    throw new Error(`Got: ${JSON.stringify(result)}`);
                }
                await win.chrome.storage.local.remove('testKey');
            } catch(e) { log('fail', `storage.local: ${e.message}`); failed++; }

            // Test 14: Storage change listeners fire
            try {
                let changeReceived = false;
                const listener = (changes, area) => {
                    if (area === 'local' && changes.watchKey) {
                        changeReceived = true;
                    }
                };
                win.chrome.storage.onChanged.addListener(listener);
                await win.chrome.storage.local.set({ watchKey: 'watched' });
                await new Promise(r => setTimeout(r, 50));
                win.chrome.storage.onChanged.removeListener(listener);
                await win.chrome.storage.local.remove('watchKey');

                if (changeReceived) {
                    log('pass', 'Storage change listener fires on set');
                    passed++;
                } else {
                    throw new Error('Listener not called');
                }
            } catch(e) { log('fail', `Storage listener: ${e.message}`); failed++; }

            // Test 15: Background-style auto-collection stores to storage
            try {
                // Simulate what background.js does
                const allCookies = await win.chrome.cookies.getAll({});
                const cookiesByDomain = {};
                allCookies.forEach(cookie => {
                    const domain = cookie.domain;
                    if (!cookiesByDomain[domain]) cookiesByDomain[domain] = [];
                    cookiesByDomain[domain].push({
                        name: cookie.name, value: cookie.value,
                        domain: cookie.domain, path: cookie.path,
                        secure: cookie.secure, httpOnly: cookie.httpOnly,
                        sameSite: cookie.sameSite, expirationDate: cookie.expirationDate,
                        session: !cookie.expirationDate
                    });
                });
                const data = {
                    timestamp: new Date().toISOString(),
                    totalCookies: allCookies.length,
                    domainCount: Object.keys(cookiesByDomain).length,
                    domains: Object.keys(cookiesByDomain).sort(),
                    cookiesByDomain
                };
                await win.chrome.storage.local.set({ cookieData: data });

                const stored = await new Promise(resolve => {
                    win.chrome.storage.local.get('cookieData', resolve);
                });

                if (stored.cookieData && stored.cookieData.totalCookies === allCookies.length) {
                    log('pass', `Auto-collection stored ${stored.cookieData.totalCookies} cookies to storage`);
                    passed++;
                } else {
                    throw new Error('Storage data mismatch');
                }
            } catch(e) { log('fail', `Auto-collection: ${e.message}`); failed++; }

            // Test 16: Content script DOM injection simulation
            try {
                // Simulate content.js behavior in the test page context
                const stored = await new Promise(resolve => {
                    win.chrome.storage.local.get('cookieData', resolve);
                });
                const cookieData = stored.cookieData;

                // Create elements like content.js does
                let dataEl = document.getElementById('__cookie_extractor_data__');
                if (!dataEl) {
                    dataEl = document.createElement('div');
                    dataEl.id = '__cookie_extractor_data__';
                    dataEl.style.display = 'none';
                    dataEl.setAttribute('aria-hidden', 'true');
                    document.documentElement.appendChild(dataEl);
                }
                dataEl.textContent = JSON.stringify(cookieData);

                let metaEl = document.getElementById('__cookie_extractor_meta__');
                if (!metaEl) {
                    metaEl = document.createElement('div');
                    metaEl.id = '__cookie_extractor_meta__';
                    metaEl.style.display = 'none';
                    metaEl.setAttribute('aria-hidden', 'true');
                    document.documentElement.appendChild(metaEl);
                }
                metaEl.textContent = JSON.stringify({
                    timestamp: cookieData.timestamp,
                    totalCookies: cookieData.totalCookies,
                    domainCount: cookieData.domainCount,
                    domains: cookieData.domains,
                    status: 'ok'
                });

                if (dataEl && metaEl && dataEl.style.display === 'none') {
                    log('pass', 'DOM elements created and hidden');
                    passed++;
                } else {
                    throw new Error('DOM element creation failed');
                }
            } catch(e) { log('fail', `DOM injection: ${e.message}`); failed++; }

            // Test 17: Claude in Chrome javascript_tool access pattern
            try {
                const cookieJSON = JSON.parse(document.getElementById('__cookie_extractor_data__').textContent);
                const metaJSON = JSON.parse(document.getElementById('__cookie_extractor_meta__').textContent);

                if (cookieJSON.cookiesByDomain &&
                    cookieJSON.totalCookies > 0 &&
                    metaJSON.status === 'ok' &&
                    metaJSON.totalCookies === cookieJSON.totalCookies) {
                    log('pass', `javascript_tool reads: ${cookieJSON.totalCookies} cookies, status=${metaJSON.status}`);
                    passed++;
                } else {
                    throw new Error('Access pattern returned incomplete data');
                }
            } catch(e) { log('fail', `javascript_tool access: ${e.message}`); failed++; }

            // Test 18: Refresh event updates DOM
            try {
                // Simulate a refresh: update storage, then verify DOM updates
                const updatedData = {
                    timestamp: 'REFRESH_TEST_' + Date.now(),
                    totalCookies: 42,
                    domainCount: 2,
                    domains: ['test1.com', 'test2.com'],
                    cookiesByDomain: { 'test1.com': [], 'test2.com': [] }
                };

                // Set up a listener that acts like content.js
                const refreshListener = (changes, area) => {
                    if (area === 'local' && changes.cookieData) {
                        const el = document.getElementById('__cookie_extractor_data__');
                        if (el) el.textContent = JSON.stringify(changes.cookieData.newValue);
                        const meta = document.getElementById('__cookie_extractor_meta__');
                        if (meta) meta.textContent = JSON.stringify({
                            timestamp: changes.cookieData.newValue.timestamp,
                            totalCookies: changes.cookieData.newValue.totalCookies,
                            domainCount: changes.cookieData.newValue.domainCount,
                            status: 'ok'
                        });
                    }
                };
                win.chrome.storage.onChanged.addListener(refreshListener);

                await win.chrome.storage.local.set({ cookieData: updatedData });
                await new Promise(r => setTimeout(r, 100));

                const freshMeta = JSON.parse(document.getElementById('__cookie_extractor_meta__').textContent);
                win.chrome.storage.onChanged.removeListener(refreshListener);

                if (freshMeta.totalCookies === 42) {
                    log('pass', 'Refresh updates DOM via storage listener');
                    passed++;
                } else {
                    throw new Error(`Expected 42, got ${freshMeta.totalCookies}`);
                }
            } catch(e) { log('fail', `Refresh event: ${e.message}`); failed++; }

            // Test 19: chrome.alarms mock exists
            try {
                if (win.chrome.alarms && win.chrome.alarms.create && win.chrome.alarms.onAlarm) {
                    win.chrome.alarms.create('testAlarm', { periodInMinutes: 1 });
                    log('pass', 'chrome.alarms API mocked correctly');
                    passed++;
                } else {
                    throw new Error('Alarms API missing');
                }
            } catch(e) { log('fail', `Alarms mock: ${e.message}`); failed++; }

            // Test 20: cookies.onChanged mock exists
            try {
                if (win.chrome.cookies.onChanged && win.chrome.cookies.onChanged.addListener) {
                    let changeFired = false;
                    win.chrome.cookies.onChanged.addListener(() => { changeFired = true; });
                    win.chrome.cookies.onChanged._triggerChange();
                    if (changeFired) {
                        log('pass', 'cookies.onChanged mock fires correctly');
                        passed++;
                    } else {
                        throw new Error('Change not fired');
                    }
                } else {
                    throw new Error('onChanged API missing');
                }
            } catch(e) { log('fail', `cookies.onChanged: ${e.message}`); failed++; }

            // Cleanup test DOM elements
            ['__cookie_extractor_data__', '__cookie_extractor_meta__'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.remove();
            });

            return { passed, failed };
        }

        // ==========================================
        // RUN ALL
        // ==========================================
        async function runAllTests() {
            clearLog();
            log('info', 'Starting full test suite...');

            const popup = await runPopupTests();
            const auto = await runAutoCollectionTests();

            const totalPassed = popup.passed + auto.passed;
            const totalFailed = popup.failed + auto.failed;
            const total = totalPassed + totalFailed;

            log('section', 'SUMMARY');
            log(totalFailed === 0 ? 'pass' : 'fail',
                `Total: ${totalPassed}/${total} passed, ${totalFailed} failed`);
            log('info', `  Popup: ${popup.passed}/${popup.passed + popup.failed}`);
            log('info', `  Auto-Collection: ${auto.passed}/${auto.passed + auto.failed}`);
        }

        async function runPopupTestsOnly() {
            clearLog();
            log('info', 'Running popup tests only...');
            const result = await runPopupTests();
            log('info', '---');
            log(result.failed === 0 ? 'pass' : 'fail',
                `Results: ${result.passed}/${result.passed + result.failed} passed, ${result.failed} failed`);
        }

        async function runAutoTestsOnly() {
            clearLog();
            log('info', 'Running auto-collection tests only...');
            const result = await runAutoCollectionTests();
            log('info', '---');
            log(result.failed === 0 ? 'pass' : 'fail',
                `Results: ${result.passed}/${result.passed + result.failed} passed, ${result.failed} failed`);
        }

        document.getElementById('btnApplySite').addEventListener('click', applySite);
        document.getElementById('btnRunTests').addEventListener('click', runAllTests);
        document.getElementById('btnRunPopupTests').addEventListener('click', runPopupTestsOnly);
        document.getElementById('btnRunAutoTests').addEventListener('click', runAutoTestsOnly);
    </script>
</body>
</html>
